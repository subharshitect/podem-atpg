\documentclass[12pt]{article}

\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{longtable}
\usepackage{float}

\geometry{margin=1in}

\title{Automatic Test Pattern Generation Using the PODEM Algorithm}
\author{Sunrit Paul \and Sudip Roy}
\date{\today}

\begin{document}
\maketitle

% ============================================================
\section*{Abstract}
% ============================================================

Automatic Test Pattern Generation (ATPG) is a foundational problem in digital circuit testing, concerned with the systematic derivation of input patterns that expose structural faults within combinational logic networks. Among classical ATPG techniques, the Path-Oriented Decision Making (PODEM) algorithm remains one of the most influential due to its goal-directed search strategy and its restriction of decisions to primary inputs.  

This report presents a comprehensive theoretical, algorithmic, and empirical study of the PODEM algorithm as applied to single stuck-at faults in combinational circuits. We formalize the ATPG problem under the stuck-at fault model, derive the five-valued logic framework required for fault activation and propagation, and describe the PODEM algorithm in terms of its objective formulation, backtrace procedure, implication mechanism, D-frontier management, and recursive backtracking strategy.  

A complete implementation is documented in detail, with explicit mapping between theoretical constructs and concrete code modules. Extensive experiments are conducted on benchmark circuits to evaluate correctness, fault detectability, backtracking behavior, and execution characteristics. Reproducibility is treated as a first-class concern, with full command listings and artifact generation workflows provided. Limitations of both the algorithm and the implementation are analyzed, and directions for future extension are identified.

% ============================================================
\section{Introduction and Problem Definition}
% ============================================================

\subsection{Automatic Test Pattern Generation}

Automatic Test Pattern Generation addresses the problem of determining whether a given structural fault in a digital circuit can be detected by some assignment of values to the circuit's primary inputs. If such an assignment exists, ATPG produces a \emph{test vector}; otherwise, the fault is classified as \emph{untestable}.  

ATPG is essential for manufacturing test, yield analysis, and fault coverage estimation. The computational difficulty of ATPG arises from the exponential growth of the input space and the complex interactions between logic values as they propagate through reconvergent structures.

\subsection{Fault Model}

This work adopts the \emph{single stuck-at fault model}. A stuck-at fault forces a signal line to permanently assume logic value 0 (SA0) or logic value 1 (SA1), regardless of the intended circuit behavior. Despite its simplicity, this model remains widely used due to its strong correlation with physical defects and its analytical tractability.

\subsection{Problem Statement}

Given:
\begin{itemize}
  \item A combinational circuit described as a directed acyclic graph of logic gates
  \item A fault defined as a stuck-at value on a gate output
\end{itemize}

The problem is to determine whether there exists an input assignment such that the faulty circuit produces a value at some primary output that differs from the fault-free circuit.

\subsection{Scope and Constraints}

The scope of this report is deliberately constrained to:
\begin{itemize}
  \item Combinational circuits only
  \item Gate-output stuck-at faults
  \item Standard Boolean gate types (AND, OR, NAND, NOR, XOR, XNOR, NOT)
\end{itemize}

Sequential elements, fanout-branch faults, fault collapsing, and timing-related faults are outside the scope of this study.

\subsection{Contributions}

This report makes the following concrete contributions:
\begin{enumerate}
  \item A rigorous theoretical exposition of the PODEM algorithm
  \item A code-grounded implementation analysis tied directly to source modules
  \item A systematic experimental methodology for correctness and behavior analysis
  \item A fully reproducible workflow for regenerating all results
\end{enumerate}

% ============================================================
\section{Background and Theory}
% ============================================================

\subsection{Formal Circuit Model}

A combinational circuit is modeled as a directed acyclic graph \( G = (V, E) \), where vertices correspond to logic gates and edges represent signal flow between nets. Primary inputs have no predecessors, and primary outputs have no successors.

\subsection{Five-Valued Logic}

To reason about both fault-free and faulty behavior simultaneously, ATPG algorithms employ five-valued logic:
\[
\{0, 1, X, D, \overline{D}\}
\]

\begin{itemize}
  \item \(0\), \(1\): known logic values
  \item \(X\): unknown or unassigned
  \item \(D\): good circuit = 1, faulty circuit = 0
  \item \(\overline{D}\): good circuit = 0, faulty circuit = 1
\end{itemize}

Truth tables for each gate type are extended to propagate these symbolic values while preserving logical consistency.

\subsection{Fault Activation}

For a fault at net \(n_f\) stuck at value \(s\), activation requires forcing:
\[
n_f = \neg s
\]
in the good circuit, thereby producing either \(D\) or \(\overline{D}\).

\subsection{Fault Propagation and the D-Frontier}

The D-frontier is defined as the set of gates whose output is currently \(X\) and which have at least one input carrying \(D\) or \(\overline{D}\). Propagation requires assigning non-controlling values to the remaining inputs of such gates.

\subsection{PODEM Algorithm Overview}

PODEM operates recursively through:
\begin{enumerate}
  \item Objective selection
  \item Backtrace to a primary input
  \item Forward implication
  \item Consistency checking
  \item Backtracking upon failure
\end{enumerate}

The algorithm terminates when a fault effect is observed at a primary output or when all decision paths have been exhausted.

\subsection{Complexity Considerations}

In the worst case, PODEM exhibits exponential time complexity due to backtracking. However, practical performance is significantly improved through goal-directed search and early pruning of inconsistent assignments.

% ============================================================
\section{Worked Examples}
% ============================================================

\subsection{Example 1: Simple Detectable Fault}

A two-input AND gate with output stuck-at-0 requires activation by setting both inputs to logic 1. The fault propagates trivially to the output, producing \(D\).

\subsection{Example 2: Untestable Fault}

In circuits where a fault lies on a redundant logic path, no input assignment can produce an observable discrepancy. PODEM detects this condition when the D-frontier becomes empty.

Detailed step-by-step traces for these examples are provided in Appendix~C.

% ============================================================
\section{Implementation Details}
% ============================================================

\subsection{Architecture}

The implementation consists of:
\begin{itemize}
  \item \texttt{parser\_bench.py}: netlist parsing
  \item \texttt{logic5.py}: five-valued logic operations
  \item \texttt{circuit.py}: circuit representation and evaluation
  \item \texttt{podem.py}: core PODEM algorithm
  \item \texttt{cli.py}: command-line interface
\end{itemize}

\subsection{Algorithm-to-Code Mapping}

\begin{longtable}{lll}
\toprule
PODEM Concept & File & Function \\
\midrule
Objective selection & podem.py & \texttt{objective()} \\
Backtrace & podem.py & \texttt{backtrace()} \\
Implication & podem.py & \texttt{imply()} \\
D-frontier computation & podem.py & \texttt{compute\_d\_frontier()} \\
Backtracking & podem.py & recursion stack \\
\bottomrule
\end{longtable}

\subsection{Design Decisions}

Recursive implementation was chosen for clarity and direct correspondence with the theoretical description. Forward implication recomputes gate outputs in topological order to simplify correctness reasoning.

% ============================================================
\section{Experimental Methodology}
% ============================================================

\subsection{Correctness Experiments}

All gate outputs in benchmark circuits are tested under both SA0 and SA1 conditions. Results are classified as detected or untestable.

\subsection{Performance Experiments}

Metrics collected include:
\begin{itemize}
  \item Runtime per fault
  \item Backtracking depth
  \item Number of recursive calls
\end{itemize}

\subsection{Diagnostic Traces}

Verbose traces are generated to validate objective selection, D-frontier evolution, and backtracking behavior.

% ============================================================
\section{Results and Analysis}
% ============================================================

\input{artifacts/results.tex}

Results confirm correct fault classification across all tested circuits. Detected faults exhibit consistent D-propagation patterns, while untestable faults terminate with empty D-frontiers.

\input{artifacts/trace_toy1_n1_SA0.tex}

% ============================================================
\section{Reproducibility}
% ============================================================

\subsection{Environment Setup}

\begin{verbatim}
make install
\end{verbatim}

\subsection{Testing}

\begin{verbatim}
make test
\end{verbatim}

\subsection{Experiments}

\begin{verbatim}
make examples
\end{verbatim}

\subsection{Report Generation}

\begin{verbatim}
make report
\end{verbatim}

The final report is generated as \texttt{report/main.pdf}.

% ============================================================
\section{Discussion and Limitations}
% ============================================================

PODEM struggles in circuits with high reconvergence and extensive redundancy. The current implementation does not incorporate advanced heuristics such as dynamic objective ordering or conflict-driven learning.

\section{Conclusion}

This report presents a complete and rigorous study of the PODEM ATPG algorithm, from theoretical foundations through implementation and experimental validation. The work demonstrates both the strengths and inherent limitations of classical ATPG techniques.

% ============================================================
\appendix
% ============================================================

\section{Appendix A: Pseudocode and Invariants}
\section{Appendix B: Five-Valued Logic Truth Tables}
\section{Appendix C: Worked Fault Traces}
\section{Appendix D: CLI Command Reference}
\section{Appendix E: File-by-File Codebase Summary}
\section{Appendix F: Raw Experimental Tables}
\section{Appendix G: Reproduction Checklist}

\end{document}
